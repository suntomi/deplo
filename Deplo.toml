version = 1
# ---------------
# common settings
# ---------------

[common]
project_name = "deplo"
debug = { ghaction_deplo_debugger = "on", ghaction_job_debugger = "on" }

# release target branch settings
[common.release_targets]
# main branch will be released as nightly
nightly = { type = "Branch", patterns = ["main"] }
# branch which name is 'lab' will be released as lab
lab = { type = "Branch", patterns = ["lab"] }
# tag which name is started with numerals treated as release (eg. 0.1.10)
prod = { type = "Tag", patterns = ["[0-9]*"] }

# ------------
# vcs settings
# ------------

# version control system account settings
[vcs]
type = "Github"
email = "${SUNTOMI_VCS_ACCOUNT_EMAIL}"
account = "${SUNTOMI_VCS_ACCOUNT}"
key = "${SUNTOMI_VCS_ACCOUNT_KEY}"


# ------------
# ci settings
# ------------

# ci account setting, mutiple ci service can be used by creating mutiple [ci.accounts.$name] sections.
# [ci.accounts.default] should always be set.
[ci.accounts.default]
type = "GhAction"
account = "${SUNTOMI_VCS_ACCOUNT}"
key = "${SUNTOMI_VCS_ACCOUNT_KEY}"


# ------------
# job settings
# ------------

# workflow settings (CI), which runs when branch that has related pull request to release targets created/updated.
# declare job name `$job_name` like jobs.integrate.$job_name, as table element of toml
[jobs.integrate.base]
# git's changeset pattern to invoke the job. that is, integrate.base only invoked when tools/docker/Dockerfile.base is
# changed by commit.
patterns = ["tools/docker/Dockerfile.base"]
# you can set local_fallback container image. if its set, command will be executed on container of `local_fallback.image`,
# with using shell `local_fallback.shell`, if local machine's OS does not matched runner.os.
runner = { type = "Machine", os = "Linux", local_fallback = { image = "docker:20.10", shell = "sh" } }
command = """
docker build -t ghcr.io/suntomi/deplo:base -f tools/docker/Dockerfile.base tools/docker
"""

[jobs.integrate.builder]
patterns = ["tools/docker/Dockerfile.builder", "Cargo.*"]
runner = { type = "Machine", os = "Linux", local_fallback = { image = "docker:20.10", shell = "sh" } }
command = """
sh tools/scripts/copy_manifests.sh
docker build -t ghcr.io/suntomi/deplo:builder -f tools/docker/Dockerfile.builder tools/docker
"""
# tasks. task is a pre-defined command to be executed in same environment as job.
# you can use tasks to use deplo like repository of utility command, like make or rake.
tasks = {
    long_running = """
for i in `seq 1 ${COUNT:-10}`; do
    echo $i
    sleep 1
done
""",
    test = "echo 'suntomi-bot'"
}

[jobs.integrate.src]
patterns = ["*/src/*", "Cargo.*",]
runner = { type = "Machine", os = "Linux", local_fallback = { image = "ghcr.io/suntomi/deplo:builder" } }
command = "cargo build"
tasks = { test = "cargo test", home = "echo ${HOME}" }
# cache settings. file paths that is listed in paths will be preserved with tha key `keys[0]`.
# if you specify multiple keys, `keys[1..]` are used as fallback keys to search similar caches 
# that is craeted by other branches.
caches = {
    # one table entry defines a set of cache operation
    cargo = {
        # way to use variable like ${{ runner.os }} in the keys, is CI service specific. please consult each CI service's document for detail.
        keys = ["integrate-build-${{ runner.os }}-v1-${{ hashFiles('**/Cargo.lock') }}"], # each os and Cargo.lock definition
        # paths root are also CI specific
        paths = ["target", "~/.cargo/bin", "~/.cargo/registry/cache", "~/.cargo/registry/index", "~/.cargo/git/db"] # all possible cargo cache paths
    }, # last comma also valid
}

[jobs.integrate.config]
patterns = ["Deplo.toml"]
# local_fallback can be path to docker file. if you specify docker file path, deplo automatically build corresponding image
# and use it as local fallback container image.
runner = { type = "Machine", os = "Linux", local_fallback = { path = "tools/docker/Dockerfile.vmfb", shell = "sh" } }
command = "deplo init"
# commits settings. if path of files that changed after the job finish running, matched patterns, 
# deplo push or made pull request such a changes to repoisitory, after all jobs finish running.
commits = [
    { patterns = [".github/*"], for_targets = ["nightly"], push_opts = { type = "Push" } },
    { patterns = [".github/*"], for_targets = ["prod"], push_opts = { type = "PullRequest" } },
    { patterns = ["docs/*"], for_targets = ["lab"], push_opts = { type = "Push" } }
]



# workflow settings (CD), which runs when release target branches are created/updated
# declare job name `$job_name` like jobs.deploy.$job_name, as table element of toml
[jobs.deploy.base]
patterns = ["tools/docker/Dockerfile.base"]
runner = { type = "Machine", os = "Linux", local_fallback = { image = "docker:20.10", shell = "sh" } }
command = """
docker build -t ghcr.io/suntomi/deplo:base -f tools/docker/Dockerfile.base tools/docker
echo ${SUNTOMI_VCS_ACCOUNT_KEY} | docker login ghcr.io -u ${SUNTOMI_VCS_ACCOUNT} --password-stdin
docker push ghcr.io/suntomi/deplo:base
"""

[jobs.deploy.builder]
patterns = ["tools/docker/Dockerfile.builder", "Cargo.*"]
runner = { type = "Machine", os = "Linux", local_fallback = { image = "docker:20.10", shell = "sh" } }
command = """
sh tools/scripts/copy_manifests.sh
docker build -t ghcr.io/suntomi/deplo:builder -f tools/docker/Dockerfile.builder tools/docker
echo ${SUNTOMI_VCS_ACCOUNT_KEY} | docker login ghcr.io -u ${SUNTOMI_VCS_ACCOUNT} --password-stdin
docker push ghcr.io/suntomi/deplo:builder
"""

[jobs.deploy.product]
# job dependencies. deploy.product only starts to run after deploy.builder finished.
depends = ["builder"]
patterns = ["*/src/*", "Cargo.*"]
runner = { type = "Machine", os = "Linux", local_fallback = { path = "tools/docker/Dockerfile.vmfb", shell = "sh" } }
command = """
set -e
mkdir -p tools/docker/bin
. tools/scripts/setup_release_env.sh
sh tools/scripts/build_linux.sh
docker build -t ghcr.io/suntomi/deplo:${DEPLO_RELEASE_VERSION} -f tools/docker/Dockerfile tools/docker
echo ${SUNTOMI_VCS_ACCOUNT_KEY} | docker login ghcr.io -u ${SUNTOMI_VCS_ACCOUNT} --password-stdin
docker push ghcr.io/suntomi/deplo:${DEPLO_RELEASE_VERSION}

# deplo provides unified command for controlling vcs. 
# `deplo vcs release` and `deplo vcs release-assets` are used for creating release of vcs like github/gitlab
# with unified interface.
deplo vcs release ${DEPLO_RELEASE_TAG} -o name=${DEPLO_RELEASE_NAME}
deplo vcs release-assets ${DEPLO_RELEASE_TAG} tools/docker/bin/cli --replace -o name=deplo-Linux

# deplo provides dyanamically generated job output. you can use value for 'foo' and 'fuga' in jobs that depends on the job. 
deplo ci set-output foo bar
deplo ci set-output fuga hoge

# job output can be used in the job that originally create output.
if [ $(deplo d product output foo) != "bar" ]; then
    echo "failed to get output from deploy-product locally"
    exit 1
fi
"""
tasks = {
    build = """
set -e
mkdir -p tools/docker/bin
. tools/scripts/setup_release_env.sh
sh tools/scripts/build_linux.sh
"""
}

[jobs.deploy.latest]
depends = ["product"]
# latest tag of docker image is only updated when production release is created.
for_targets = ["prod"]
patterns = ["*/src/*", "Cargo.*"]
runner = { type = "Machine", os = "Linux", local_fallback = { image = "docker:20.10", shell = "sh" } }
command = """
. tools/scripts/setup_release_env.sh
echo ${SUNTOMI_VCS_ACCOUNT_KEY} | docker login ghcr.io -u ${SUNTOMI_VCS_ACCOUNT} --password-stdin
docker pull ghcr.io/suntomi/deplo:${DEPLO_RELEASE_VERSION}
docker tag ghcr.io/suntomi/deplo:${DEPLO_RELEASE_VERSION} ghcr.io/suntomi/deplo:latest
docker push ghcr.io/suntomi/deplo:latest
"""

[jobs.deploy.mac]
depends = ["product"]
patterns = ["*/src/*", "Cargo.*"]
runner = { type = "Machine", os = "MacOS" }
steps = [{
    name = "before test"
    env = { HOGE = "hoge" },
    workdir = "docs",
    shell = "sh",
    command = """
    if [ "$(echo $HOGE)" != "hoge" ]; then
        echo "env does not work"
        exit 1
    fi
    if [ -z "$(ls -al ./envs.md)" ]; then
        ls -al
        echo "workdir does not work"
        exit 1
    fi
    if [ "$(echo $0)" != "sh" ]; then
        echo "shell does not work"
        exit 1
    fi
    """
}, {
    command = """
    set -e
    . tools/scripts/setup_release_env.sh
    cargo build --release
    deplo vcs release-assets ${DEPLO_RELEASE_TAG} target/release/cli --replace -o name=deplo-Darwin
    # deploy-mac depends on deploy-product, so can use its output
    if [ "$(deplo d product output foo)" != "bar" ]; then
        echo "failed to get output from deploy-product"
        exit 1
    fi
    """
}, {
    name = "after test"
    env = { FUGA = "fuga" },
    shell = "bash",
    workdir = ".vscode",
    command = """
    if [ "$(echo $FUGA)" != "fuga" ]; then
        echo "env does not work"
        exit 1
    fi
    if [ -z "$(ls -al launch.json)" ]; then
        ls -al
        echo "workdir does not work"
        exit 1
    fi
    if [ "$(echo $0)" != "bash" ]; then
        echo "shell does not work"
        exit 1
    fi
    """,
}]
caches.cargo = {
    keys = ["integrate-build-${{ runner.os }}-v1-${{ hashFiles('**/Cargo.lock') }}"],
    paths = ["target", "~/.cargo/bin", "~/.cargo/registry/cache", "~/.cargo/registry/index", "~/.cargo/git/db"]
}

[jobs.deploy.win]
depends = ["product"]
patterns = [".*/src/.*", 'Cargo\.*']
options = { diff_matcher = "regex" }
runner = { type = "Machine", os = "Windows" }
command = """
set -e
. tools/scripts/setup_release_env.sh
cargo build --release
deplo vcs release-assets ${DEPLO_RELEASE_TAG} target/release/cli.exe --replace -o name=deplo-Windows.exe
deplo vcs release-assets ${DEPLO_RELEASE_TAG} target/release/cli.pdb --replace -o name=deplo-Windows.pdb
# deploy-win depends on deploy-product, so can use its output
if [ $(deplo d product output fuga) != "hoge" ]; then
    echo "failed to get output from deploy-product"
    exit 1
fi
"""
caches = {
    cargo = {
        keys = ["integrate-build-${{ runner.os }}-v1-${{ hashFiles('**/Cargo.lock') }}"],
        paths = ["target", "~/.cargo/bin", "~/.cargo/registry/cache", "~/.cargo/registry/index", "~/.cargo/git/db"]
    }
}
